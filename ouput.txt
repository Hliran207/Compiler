DEBUG: Entering function definition for 'foo'
DEBUG: Visiting node with token: PARAM
DEBUG: Extracting type from: REAL
param_count=1 
DEBUG: Visiting node with token: PARAM
DEBUG: Extracting type from: REAL
DEBUG: Adding parameter 'x' of type 'REAL' to scope 2
DEBUG: get_expression_type called with token: '23'
DEBUG: Returning TYPE_INT for numeric literal '23'
DEBUG: get_expression_type called with token: '10'
DEBUG: Returning TYPE_INT for numeric literal '10'
DEBUG: get_expression_type called with token: '19'
DEBUG: Returning TYPE_INT for numeric literal '19'
DEBUG: get_expression_type called with token: '=='
DEBUG: get_expression_type called with token: 'a'
DEBUG: Looking up variable 'a' in current scope 2
DEBUG: Found variable 'a' with type INT in scope 2
DEBUG: get_expression_type called with token: '23'
DEBUG: Returning TYPE_INT for numeric literal '23'
DEBUG: get_expression_type called with token: '+'
DEBUG: Processing binary operator '+'
DEBUG: get_expression_type called with token: 'b'
DEBUG: Looking up variable 'b' in current scope 2
DEBUG: Found variable 'b' with type INT in scope 2
DEBUG: get_expression_type called with token: 'a'
DEBUG: Looking up variable 'a' in current scope 2
DEBUG: Found variable 'a' with type INT in scope 2
DEBUG: Binary op '+' - left_type: INT, right_type: INT
DEBUG: Binary op '+' returning TYPE_INT

=== Symbol Table ===
Name                 Type       Kind       Scope    Line    
------------------------------------------------
b                    INT        Variable   2        2       
a                    INT        Variable   2        2       
x                    REAL       Parameter  2        1       
foo                  INT        Function   1        1       
------------------------------------------------
param_count=0 
DEBUG: get_expression_type called with token: '0'
DEBUG: Returning TYPE_INT for numeric literal '0'
DEBUG: get_expression_type called with token: '3.14'
DEBUG: Returning TYPE_REAL for numeric literal '3.14'
DEBUG: get_expression_type called with token: '+'
DEBUG: Processing binary operator '+'
DEBUG: get_expression_type called with token: 'a'
DEBUG: Looking up variable 'a' in current scope 3
DEBUG: Found variable 'a' with type INT in scope 2
DEBUG: get_expression_type called with token: 'b'
DEBUG: Looking up variable 'b' in current scope 3
DEBUG: Found variable 'b' with type INT in scope 2
DEBUG: Binary op '+' - left_type: INT, right_type: INT
DEBUG: Binary op '+' returning TYPE_INT
DEBUG: get_expression_type called with token: '<'
DEBUG: get_expression_type called with token: 'a'
DEBUG: Looking up variable 'a' in current scope 2
DEBUG: Found variable 'a' with type INT in scope 2
DEBUG: get_expression_type called with token: '10'
DEBUG: Returning TYPE_INT for numeric literal '10'

=== Symbol Table ===
Name                 Type       Kind       Scope    Line    
------------------------------------------------
b                    INT        Variable   2        15      
a                    INT        Variable   2        15      
_main_               VOID       Function   1        14      
foo                  INT        Function   1        1       
------------------------------------------------
(Function_list
	(FUNCTION
		(foo)
	(FUNC_PARTS
		(PARAMETERS
			(PARAM
				(REAL)
			(x)
			)
		)
	(DEF_BODY
		(RETURNS
			(INT)
		)
	(BODY
		(VAR_DECL
			(INT)
		(VAR_ITEM_LIST
			(VAR
				(a)
			)
		(VAR
			(b)
		)
		)
		)
	(statements
		(statements
			(STATEMENT
				(assign
					(a)
				(23)
				)
			)
		(statements
			(if-else
				(==
					(a)
				(23)
				)
			(then
				(BLOCK
					(VAR_EMPTY)
				(statements
					(STATEMENT
						(assign
							(b)
						(10)
						)
					)
				(empty_state_list)
				)
				)
			(else
				(STATEMENT
					(assign
						(b)
					(19)
					)
				)
			)
			)
			)
		(statements
			(RETURN
				(+
					(b)
				(a)
				)
			)
		(empty_state_list)
		)
		)
		)
	)
	)
	)
	)
	)
(PROCEDURE
	(_main_)
(PROC_PARTS
	(PARAMETERS
		(PARAM_EMPTY)
	)
(BODY
	(VAR_DECL
		(INT)
	(VAR_ITEM_LIST
		(VAR
			(a)
		)
	(VAR
		(b)
	)
	)
	)
(statements
	(STATEMENT
		(assign
			(a)
		(0)
		)
	)
(statements
	(while
		(<
			(a)
		(10)
		)
	(BLOCK
		(VAR_EMPTY)
	(statements
		(ASSIGNMENT
			(b)
		(CALL
			(foo)
		(3.14)
		)
		)
	(statements
		(STATEMENT
			(assign
				(a)
			(+
				(a)
			(b)
			)
			)
		)
	(empty_state_list)
	)
	)
	)
	)
(empty_state_list)
)
)
)
)
)
)
Parsing and semantic analysis completed successfully.
----------------------------------------3AC-----------------------------------.
DEBUG: Processing function foo
DEBUG: Function node type: FUNCTION
DEBUG: Body node type: BODY
DEBUG: About to process statements
DEBUG: genStmt processing node: statements
DEBUG: genStmt processing node: statements
DEBUG: genStmt processing node: STATEMENT
DEBUG: genStmt processing node: assign
DEBUG: genExpr processing: 23
DEBUG: get_expression_type called with token: '23'
DEBUG: Returning TYPE_INT for numeric literal '23'
DEBUG: genStmt processing node: statements
DEBUG: genStmt processing node: if-else
DEBUG: genStmt processing node: BLOCK
DEBUG: genStmt processing node: statements
DEBUG: genStmt processing node: STATEMENT
DEBUG: genStmt processing node: assign
DEBUG: genExpr processing: 10
DEBUG: get_expression_type called with token: '10'
DEBUG: Returning TYPE_INT for numeric literal '10'
DEBUG: genStmt processing node: empty_state_list
DEBUG: genStmt processing node: STATEMENT
DEBUG: genStmt processing node: assign
DEBUG: genExpr processing: 19
DEBUG: get_expression_type called with token: '19'
DEBUG: Returning TYPE_INT for numeric literal '19'
DEBUG: genStmt processing node: statements
DEBUG: genStmt processing node: RETURN
DEBUG: genExpr processing: +
DEBUG: genStmt processing node: empty_state_list
DEBUG: Processing function main
DEBUG: Function node type: PROCEDURE
DEBUG: Body node type: BODY
DEBUG: About to process statements
DEBUG: genStmt processing node: statements
DEBUG: genStmt processing node: STATEMENT
DEBUG: genStmt processing node: assign
DEBUG: genExpr processing: 0
DEBUG: get_expression_type called with token: '0'
DEBUG: Returning TYPE_INT for numeric literal '0'
DEBUG: genStmt processing node: statements
DEBUG: genStmt processing node: while
DEBUG: genStmt processing node: BLOCK
DEBUG: genStmt processing node: statements
DEBUG: genStmt processing node: ASSIGNMENT
DEBUG: genExpr processing: CALL
DEBUG: genStmt processing node: statements
DEBUG: genStmt processing node: STATEMENT
DEBUG: genStmt processing node: assign
DEBUG: genExpr processing: +
DEBUG: genStmt processing node: empty_state_list
DEBUG: genStmt processing node: empty_state_list
3AC written to output.ac3
